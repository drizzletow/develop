# 一 概念与意义

## 1. 设计模式的概念

软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。



## 2. 设计模式的意义

设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。

- 可以提高程序员的思维能力、编程能力和设计能力。
- 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。
- 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。
  - 代码重用性 (即：相同功能的代码，不用多次编写) 
  - 可读性 (即：编程规范性, 便于其他程序员的阅读和理解) 
  - 可扩展性 (即：当需要增加新的功能时，非常的方便，又称为可维护性) 
  - 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响) 
  - 使程序呈现高内聚，低耦合的特性


当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。





# 二 设计模式七大原则

| 设计原则     | 归纳                                                         | 目的                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------ |
| 开闭原则     | 对扩展开放，对修改关闭                                       | 降低维护带来的新风险                       |
| 单一职责原则 | 一个类只干一件事，实现类要单一                               | 便于理解，提高代码的可读性                 |
| 接口隔离原则 | 一个接口只干一件事，接口要精简单一                           | 功能解耦，高聚合、低耦合                   |
| 依赖倒置原则 | 高层不应该依赖低层，要面向接口编程                           | 更利于代码结构的升级扩展                   |
| 里氏替换原则 | 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 | 防止继承泛滥                               |
| 迪米特法则   | 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 | 只和朋友交流，不和陌生人说话，减少代码臃肿 |
| 合成复用原则 | 尽量使用组合或者聚合关系实现代码复用，少使用继承             | 降低代码耦合                               |



## 1. 开闭原则OCP

开闭原则（Open Closed Principle，OCP）：

> 开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：
>
> 软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification）



开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。即软件实体（模块、类、方法）应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化，



**开闭原则的实现方法**：

可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。



开闭原则是最基础的一个原则，其余的原则都是开闭原则的具体形态，也就是说其他原则就是指导设计的工具和方法，而开闭原则才是其精神领袖。换一个角度来理解，依照Java语言的称谓，开闭原则是抽象类，其他五大原则是具体的实现类，开闭原则在面向对象设计领域中的地位就类似于牛顿第一定律在力学、勾股定律在几何学、质能方程在狭义相对论中的地位，其地位无人能及。





## 2. 单一职责原则

单一职责原则的英文名称是Single Responsibility Principle，简称是SRP

- 接口一定要做到单一职责
- <font color=red>类的设计尽量做到只有一个原因引起变化 （主要）</font> 
- 单一职责同样也适用于方法，一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。

类的单一职责确实受非常多因素的制约，纯理论地来讲，这个原则是非常优秀的，但是现实有现实的难处，你必须去考虑项目工期、成本、人员技术水平、硬件情况、网络情况甚至有时候还要考虑政府政策、垄断协议等因素。
因此应用单一职责原则时在很多地方可以看到：This is sometimes hard to see"（这个有时候很难说）

这个设计原则同时也备受争议，只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的  ![](vx_images/2792234220247.png) 

上来直接就问：你设计的类符合SRP原则吗？<img src="vx_images/760336238673.png" style="zoom:25%;" />  

<br/>

对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：

- 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
- 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

<br/>

单一职责原则的优点

- 单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。
- 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
- 提高类的可读性。复杂性降低，自然其可读性会提高。
- 提高系统的可维护性。可读性提高，那自然更容易维护了。
- 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。





## 3. 接口隔离原则

 接口隔离原则（Interface Segregation Principle，ISP）

- Clients should not be forced to depend upon interfaces that they don't use.（客户端不应该依赖它不需要的接口。）

- The dependency of one class to another one should depend on the smallest possible interface.（类间的依赖关系应该建立在最小的接口上。）

  

**实践与应用**：

接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装。但是，这个原子该怎么划分是设计模式中的一大难题，在实践中可以根据以下几个规则来衡量：

- 一个接口只服务于一个子模块或业务逻辑；
- 通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；
- 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；
- 了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！


<br/>

接口分为两种：

- 实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物的描述，这是一种接口。
  比如你定义Person这个类，然后使用 ```Person zhangSan=new Person()``` 产生了一个实例，这个实例要遵从的标准就是Person这个类，Person类就是zhangSan的接口。疑惑？看不懂？不要紧，那是因为让Java语言浸染的时间太长了，只要知道从这个角度来看，Java中的类也是一种接口。
- 类接口（Class Interface），Java中经常使用的interface关键字定义的接口





## 4. 依赖倒置原则

依赖倒置原则（Dependence Inversion Principle,DIP）。“面向接口编程”——OOD（Object-Oriented Design，也就是面向对象设计）的精髓之一。

- High level modules should not depend upon low level modules. Both should depend upon abstractions.
- Abstractions should not depend upon details. Details should depend upon abstractions.

<br/>

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
- 抽象不应该依赖细节、细节应该依赖抽象。

<br/>

依赖倒置原则在Java语言中的表现就是：

- 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
- 接口或抽象类不依赖于实现类；实现类依赖接口或抽象类。





## 5.  里氏替换原则

 里氏替换原则（Liskov Substitution Principle，LSP）

- <font color=red>子类可以扩展父类的功能，但不能改变父类原有的功能 </font>
- <font color=red>所有引用基类的地方必须能透明地使用其子类的对象 </font>

在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

<br/>

里氏替换原则主要阐述了<font color=red>有关继承的一些原则</font>，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原则是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。





## 6. 迪米特法则

 迪米特法则（Law of Demeter，LoD））也称为最少知识原则（Least Knowledge Principle，LKP）

 Talk only to your immediate friends and not to strangers （只与直接的朋友通信。）

- 一个方法尽量不引入一个类中不存在的对象（当然，JDK API提供的类除外）
- 如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中

人和人之间是有距离的，太远关系逐渐疏远，最终形同陌路；太近就相互刺伤。对朋友关系描述最贴切的故事就是：两只刺猬取暖，太远取不到暖，太近刺伤了对方，必须保持一个既能取暖又不刺伤对方的距离。迪米特法则就是对这个距离进行描述，即使是朋友类之间也不能无话不说，无所不知。



**迪米特法则的实现与注意事项**：

从迪米特法则的定义和特点可知，它强调以下两点：

- 从依赖者的角度来说，只依赖应该依赖的对象。
- 从被依赖者的角度说，只暴露应该暴露的方法。

<br/>

所以，在运用迪米特法则时要注意以下 6 点：

- 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
- 在类的结构设计上，尽量降低类成员的访问权限。
- 在类的设计上，优先考虑将一个类设置成不变类。
- 在对其他类的引用上，将引用其他对象的次数降到最低。
- 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
- 谨慎使用序列化（Serializable）功能。





## 7. 合成复用原则

合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。

它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。



**合成复用原则的重要性**：

通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：

1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。


采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。

1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。





# 三 23种设计模式

| 设计模式                                       | 简述                                                         | 一句话归纳                     | 目的                   | 举例           |
| ---------------------------------------------- | :----------------------------------------------------------- | ------------------------------ | ---------------------- | -------------- |
| 工厂模式（Factory Pattern）                    | 不同条件下创建不同实例                                       | 产品标准化，生产更高效         | 封装创建细节           | 实体工厂       |
| 单例模式（Singleton  Pattern）                 | 保证一个类仅有一个实例，并且提供一个全局访问点               | 世上只有一个我                 | 保证独一无二           | CEO            |
| 原型模式（Prototype Pattern）                  | 通过拷贝原型创建新的对象                                     | 拔一根猴毛，吹出千万个         | 高效创建对象           | 克隆           |
| 建造者模式（Builder  Pattern）                 | 用来创建复杂的复合对象                                       | 高配中配和低配，想选哪配就哪配 | 开放个性配置步骤       | 选配           |
| 代理模式（Proxy Pattern）                      | 为其他对象提供一种代理以控制对这个对象的访问                 | 没有资源没时间，得找别人来帮忙 | 增强职责               | 媒婆           |
| 外观模式（Facade  Pattern）                    | 对外提供一个统一的接口用来访问子系统                         | 打开一扇门，通向全世界         | 统一访问入口           | 前台           |
| 装饰器模式（Decorator Pattern）                | 为对象添加新功能                                             | 他大舅他二舅都是他舅           | 灵活扩展、同宗同源     | 煎饼           |
| 享元模式（Flyweight  Pattern）                 | 使用对象池来减少重复对象的创建                               | 优化资源配置，减少重复浪费     | 共享资源池             | 全国社保联网   |
| 组合模式（Composite Pattern）                  | 将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理 | 人在一起叫团伙，心在一起叫团队 | 统一整体和个体         | 组织架构树     |
| 适配器模式（Adapter  Pattern）                 | 将原来不兼容的两个类融合在一起                               | 万能充电器                     | 兼容转换               | 电源适配       |
| 桥接模式（Bridge Pattern）                     | 将两个能够独立变化的部分分离开来                             | 约定优于配置                   | 不允许用继承           | 桥             |
| 模板模式（Template  Pattern）                  | 定义一套流程模板，根据需要实现模板中的操作                   | 流程全部标准化，需要微调请覆盖 | 逻辑复用               | 把大象装进冰箱 |
| 策略模式（Strategy Pattern）                   | 封装不同的算法，算法之间能互相替换                           | 条条大道通罗马，具体哪条你来定 | 把选择权交给用户       | 选择支付方式   |
| 责任链模式（Chain  of Responsibility Pattern） | 拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 | 各人自扫门前雪，莫管他们瓦上霜 | 解耦处理逻辑           | 踢皮球         |
| 迭代器模式（Iterator Pattern）                 | 提供一种方法顺序访问一个聚合对象中的各个元素                 | 流水线上坐一天，每个包裹扫一遍 | 统一对集合的访问方式   | 逐个检票进站   |
| 命令模式（Command  Pattern）                   | 将请求封装成命令，并记录下来，能够撤销与重做                 | 运筹帷幄之中，决胜千里之外     | 解耦请求和处理         | 遥控器         |
| 状态模式（State Pattern）                      | 根据不同的状态做出不同的行为                                 | 状态驱动行为，行为决定状态     | 绑定状态和行为         | 订单状态跟踪   |
| 备忘录模式（Memento  Pattern）                 | 保存对象的状态，在需要时进行恢复                             | 失足不成千古恨，想重来时就重来 | 备份、后悔机制         | 草稿箱         |
| 中介者模式（Mediator Pattern）                 | 将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散 | 联系方式我给你，怎么搞定我不管 | 统一管理网状资源       | 朋友圈         |
| 解释器模式（Interpreter  Pattern）             | 给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子 | 我想说”方言“，一切解释权都归我 | 实现特定语法解析       | 摩斯密码       |
| 观察者模式（Observer Pattern）                 | 状态发生改变时通知观察者，一对多的关系                       | 到点就通知我                   | 解耦观察者与被观察者   | 闹钟           |
| 访问者模式（Visitor  Pattern）                 | 稳定数据结构，定义新的操作行为                               | 横看成岭侧成峰，远近高低各不同 | 解耦数据结构和数据操作 | KPI考核        |
| 委派模式（Delegate Pattern）                   | 允许对象组合实现与继承相同的代码重用，负责任务的调用和分配   | 这个需求很简单，怎么实现我不管 | 只对结果负责           | 授权委托书     |



## 1. 5种创建型模式

- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

以上 5 种创建型模式，除了[工厂方法模式](http://c.biancheng.net/view/1348.html)属于类创建型模式，其他的全部属于对象创建型模式



## 2. 7种结构型模式

1. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
2. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
3. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
4. 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
5. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
6. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
7. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。


以上 7 种结构型模式，除了[适配器模式](http://c.biancheng.net/view/1361.html)分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式



## 3. 11种行为型模式

行为型模式是 GoF [设计模式](http://c.biancheng.net/design_pattern/)中最为庞大的一类，它包含以下 11 种模式。

1. 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
2. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
3. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
4. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
5. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
6. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
7. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
8. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
9. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
10. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
11. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。


以上 11 种行为型模式，除了模板方法模式和[解释器模式](http://c.biancheng.net/view/1402.html)是类行为型模式，其他的全部属于对象行为型模式























